import os
import shutil
import zipfile
import rarfile
import py7zr
import sys
import json

# ==============================================================================
# This script now reads its settings from a config.json file
# that is created in the same folder as the .exe
# ==============================================================================

def get_base_path():
    """Gets the base path for the executable or script."""
    if getattr(sys, 'frozen', False):
        # We are running in a bundle (e.g., PyInstaller)
        return os.path.dirname(sys.executable)
    else:
        # We are running in a normal Python environment
        return os.path.dirname(os.path.abspath(__file__))

def load_or_create_config(config_path):
    """Loads the config file or creates a default one if it doesn't exist."""
    default_config = {
        "MUGEN_PATH": "C:/path/to/your/mugen",
        "DOWNLOADS_PATH": "C:/path/to/your/downloads/mugen_chars",
        "CLEANUP_ARCHIVES": True
    }
    
    try:
        with open(config_path, 'r') as f:
            print("-> Found config.json. Loading settings.")
            return json.load(f)
    except FileNotFoundError:
        print("-> config.json not found. Creating a default one now.")
        print(f"   Please edit '{config_path}' with your actual folder paths and re-run the script.")
        with open(config_path, 'w') as f:
            json.dump(default_config, f, indent=4)
        return None # Return None to signal that the user needs to edit the file
    except json.JSONDecodeError:
        print(f"ERROR: '{config_path}' is corrupted or badly formatted.")
        print("       Please fix it or delete it to regenerate a default file.")
        return None

# The rest of the script is the same as before...
# (Functions for extracting, finding folders, and updating select.def)

def extract_archive(archive_path, extract_to):
    """Extracts a supported archive to a specified folder."""
    print(f"-> Extracting '{os.path.basename(archive_path)}'...")
    try:
        if archive_path.endswith('.zip'):
            with zipfile.ZipFile(archive_path, 'r') as zip_ref:
                zip_ref.extractall(extract_to)
        elif archive_path.endswith('.rar'):
            with rarfile.RarFile(archive_path, 'r') as rar_ref:
                rar_ref.extractall(extract_to)
        elif archive_path.endswith('.7z'):
            with py7zr.SevenZipFile(archive_path, mode='r') as z_ref:
                z_ref.extractall(path=extract_to)
        else:
            return False
        print("   Extraction successful.")
        return True
    except Exception as e:
        print(f"   ERROR: Failed to extract archive. Reason: {e}")
        return False

def find_character_folder(base_path):
    """Finds the main character folder within the extracted files."""
    contents = os.listdir(base_path)
    if not contents: return None
    
    # Best case: A single folder is in the root
    if len(contents) == 1 and os.path.isdir(os.path.join(base_path, contents[0])):
        char_folder = contents[0]
        if os.path.isfile(os.path.join(base_path, char_folder, f"{char_folder}.def")):
            return char_folder

    # Search for a folder containing a .def file with the same name
    for item in contents:
        item_path = os.path.join(base_path, item)
        if os.path.isdir(item_path):
            def_file = os.path.join(item_path, f"{item}.def")
            if os.path.isfile(def_file):
                return item
    
    # Fallback: if no .def file is found, assume the most likely folder is correct
    # This helps with poorly packaged characters.
    potential_folders = [d for d in contents if os.path.isdir(os.path.join(base_path, d))]
    if potential_folders:
        return potential_folders[0]

    return None

def add_char_to_select_def(char_name, select_def_path):
    """Adds a character name to select.def if it's not already there."""
    print(f"-> Updating select.def for '{char_name}'...")
    
    with open(select_def_path, 'r', encoding='utf-8', errors='ignore') as f:
        lines = f.readlines()

    for line in lines:
        if line.strip().lower().startswith(char_name.lower()):
            print(f"   INFO: '{char_name}' is already present in select.def. Skipping.")
            return True

    new_lines = []
    in_chars_section = False
    inserted = False
    for line in lines:
        if line.strip().lower() == '[characters]':
            in_chars_section = True
        elif in_chars_section and line.strip().startswith('['):
            if not inserted:
                new_lines.append(f"{char_name}\n")
                inserted = True
            in_chars_section = False
        new_lines.append(line)
    
    # If [Characters] section exists but the loop finished without inserting
    if in_chars_section and not inserted:
        new_lines.append(f"{char_name}\n")
        inserted = True

    if not any(line.strip().lower() == '[characters]' for line in lines) and not inserted:
        print("   ERROR: Could not find the [Characters] section in select.def.")
        return False

    try:
        with open(select_def_path, 'w', encoding='utf-8', errors='ignore') as f:
            f.writelines(new_lines)
        print("   select.def updated successfully.")
        return True
    except Exception as e:
        print(f"   ERROR: Could not write to select.def. Reason: {e}")
        return False

def main():
    """Main function to run the installer."""
    base_path = get_base_path()
    config_path = os.path.join(base_path, 'config.json')
    config = load_or_create_config(config_path)

    if config is None:
        input("\nPress Enter to exit.")
        return

    MUGEN_PATH = config.get("MUGEN_PATH")
    DOWNLOADS_PATH = config.get("DOWNLOADS_PATH")
    CLEANUP_ARCHIVES = config.get("CLEANUP_ARCHIVES", True)
    
    if not os.path.isdir(MUGEN_PATH) or not os.path.isdir(DOWNLOADS_PATH):
        print("\nERROR: The paths in config.json are not valid folders.")
        print("       Please correct the paths and run again.")
        input("Press Enter to exit.")
        return

    CHARS_FOLDER = os.path.join(MUGEN_PATH, 'chars')
    SELECT_DEF_PATH = os.path.join(MUGEN_PATH, 'data', 'select.def')
    TEMP_EXTRACT_FOLDER = os.path.join(base_path, '_temp_extract')

    archives = [f for f in os.listdir(DOWNLOADS_PATH) if f.endswith(('.zip', '.rar', '.7z'))]
    if not archives:
        print("No new character archives found in the downloads folder.")
        input("Press Enter to exit.")
        return

    print(f"Found {len(archives)} character archive(s) to process.\n")
    for archive_name in archives:
        print(f"--- Processing: {archive_name} ---")
        archive_path = os.path.join(DOWNLOADS_PATH, archive_name)
        if os.path.exists(TEMP_EXTRACT_FOLDER): shutil.rmtree(TEMP_EXTRACT_FOLDER)
        os.makedirs(TEMP_EXTRACT_FOLDER)

        if not extract_archive(archive_path, TEMP_EXTRACT_FOLDER): continue
        
        char_folder_name = find_character_folder(TEMP_EXTRACT_FOLDER)
        if not char_folder_name:
            print("   ERROR: Could not identify a valid character folder. Skipping.")
            continue
        
        print(f"   Identified character folder: '{char_folder_name}'")
        
        destination_path = os.path.join(CHARS_FOLDER, char_folder_name)
        if os.path.exists(destination_path):
            print(f"   WARNING: Character '{char_folder_name}' already exists. Skipping.")
            continue

        source_path = os.path.join(TEMP_EXTRACT_FOLDER, char_folder_name)
        shutil.move(source_path, CHARS_FOLDER)
        print(f"   Moved '{char_folder_name}' to chars folder.")

        if add_char_to_select_def(char_folder_name, SELECT_DEF_PATH):
            if CLEANUP_ARCHIVES:
                os.remove(archive_path)
                print(f"   Removed original archive: '{archive_name}'")
        
        shutil.rmtree(TEMP_EXTRACT_FOLDER)
        print(f"--- Finished processing: {archive_name} ---\n")

    print("=========================")
    print("All tasks completed.")
    input("Press Enter to exit.")

if __name__ == "__main__":
    main()
